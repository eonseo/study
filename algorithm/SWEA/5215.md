문제 이름 또는 번호: 5215 / 햄버거 다이어트

코드(선택): cpp

오늘의 메모: 냅색 알고리즘을 이용하여 풀기. 처음에는 dp 배열을 2차원 배열로 만들어서 풀었으나, 1차원배열로도 풀 수 있다는 것을 알게 되었다.

냅색 알고리즘의 기본적인 정의는, 해당 물건을 고르는지, 안고르는지에 대한 경우를 나누는 것이다.

해당 햄버거 재료를 고르지 못하는 경우, dp[i][j] 의 값은 `dp[i - 1][j]` 가 된다. 이는 곧, i를 고르지 않았을 경우(i - 1) j 칼로리를 최대 칼로리로 봤을 때 얻을 수 있는 최대 score 을 뜻한다.

해당 햄버거 재료를 고를 수 있는 경우, dp[i][j] 의 값은 `max(score[i] + dp[i - 1][j - cal[i]])` 이 된다. 즉, 해당 햄버거 재료의 점수와 해당 햄버거를 고르지 않은 경우 최대 칼로리를 `j - cal[i]`(j 에서 해당 햄버거 재료의 칼로리를 뺀 값)으로 봤을 때 얻을 수 있는 최대 점수를 더한 값이다.

### 1. dp 배열을 2차원 배열로 할당한 코드

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, maxCal;

void init(int*& score, int*& cal, int**& dp) {
	score = new int[n + 1];
	cal = new int[n + 1];
	dp = new int*[n + 1];
	for (int i = 0; i <= n; i++) dp[i] = new int[maxCal + 1]();
}

void destroy(int*& score, int*& cal, int**& dp) {
	delete[] score;
	delete[] cal;
	for (int i = 0; i <= n; i++) delete[] dp[i];
	delete[] dp;
}

int main() {
	int t;
	int* score, *cal, **dp;

	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		cin >> n >> maxCal;
		init(score, cal, dp);

		for (int i = 1; i <= n; i++) {
			cin >> score[i] >> cal[i];
		}

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= maxCal; j++) {
				if (j >= cal[i])
					dp[i][j] = max(dp[i - 1][j], score[i] + dp[i - 1][j - cal[i]]);
				else
					dp[i][j] = dp[i - 1][j];
			}
		}

		cout << "#" << tc << " " << dp[n][maxCal] << "\n";
		destroy(score, cal, dp);
	}
}
```

### 2. dp 배열을 1차원 배열로 할당한 코드

dp[j] 는 j 최대 칼로리를 j 라고 가정했을 때 얻을 수 있는 최대 맛 점수를 뜻한다.

각 아이템마다 `for (j = maxCal; j >= cal[i]; j--)` 를 역순 순회해서 중복을 방지하고, `max(score[i] + dp[i - 1][j - cal[i]])` 라는 점화식으로 이 재료를 선택한 경우와 선택하지 않은 경우를 비교하여 최댓값을 찾는 과정을 반복한다.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, maxCal;

void init(int*& score, int*& cal, int*& dp) {
	score = new int[n + 1];
	cal = new int[n + 1];
	dp = new int[maxCal + 1]();
}

void destroy(int*& score, int*& cal, int*& dp) {
	delete[] score;
	delete[] cal;
	delete[] dp;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	int t;
	int* score, *cal, *dp;

	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		cin >> n >> maxCal;
		init(score, cal, dp);

		for (int i = 1; i <= n; i++) {
			cin >> score[i] >> cal[i];
		}

		for (int i = 1; i <= n; i++) {
			for (int j = maxCal; j >= cal[i]; j--) {
				dp[j] = max(dp[j], score[i] + dp[j - cal[i]]);
			}
		}

		cout << "#" << tc << " " << dp[maxCal] << "\n";
		destroy(score, cal, dp);
	}
}
```

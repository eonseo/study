# 비트 연산자

| 연산자 |            의미             |  사용법  | 예제 (8비트 2진수)                                                  | 설명                                                                   |
| :----: | :-------------------------: | :------: | :------------------------------------------------------------------ | :--------------------------------------------------------------------- |
|  `&`   |        AND (논리곱)         | `x & y`  | x=00000011(2)=3, <br>y=00000110(2)=6,<br> x & y -> 00000010(2) = 2  | 두 비트가 모두 1일 경우에만 1이 됩니다.                                |
|  `\|`  |         OR (논리합)         | `x \| y` | x=00000011(2)=3,<br> y=00000110(2)=6,<br> x \| y -> 00000111(2) = 7 | 두 비트 중 하나라도 1이면 1이 됩니다.                                  |
|  `^`   |     XOR (배타적 논리합)     | `x \^ y` | x=00000011(2)=3,<br> y=00000110(2)=6,<br> x \^ y -> 00000101(2) = 5 | 두 비트가 같으면 0, 다르면 1이 됩니다.                                 |
|  `~`   |       NOT (비트 반전)       |   `~x`   | x=00000010(2)=2,<br> ~x -> 11111101(2) = 253                        | 각 비트를 반전시킵니다 (0이면 1, 1이면 0).                             |
|  `<<`  |  Left Shift (왼쪽 시프트)   | `x << 2` | x=00000001(2)=1,<br> x << 2 -> 00000100(2) = 4                      | 비트를 왼쪽으로 이동. 하나 이동할 때마다 2를 곱하는 효과가 있습니다.   |
|  `>>`  | Right Shift (오른쪽 시프트) | `x >> 2` | x=00000100(2)=4,<br> x >> 2 -> 00000001(2) = 1                      | 비트를 오른쪽으로 이동. 하나 이동할 때마다 2로 나누는 효과가 있습니다. |

# 비트를 이용한 부분집합

| 십진수 | 이진수 | {A, B, C, D} |
| :----: | :----: | :----------: |
|   0    |  0000  |      {}      |
|   1    |  0001  |     {A}      |
|   2    |  0010  |     {B}      |
|   3    |  0011  |    {A, B}    |
|   4    |  0100  |     {C}      |
|   5    |  0101  |    {A, C}    |
|   6    |  0110  |    {B, C}    |
|   7    |  0111  |  {A, B, C}   |
|   8    |  1000  |     {D}      |
|   9    |  1001  |    {A, D}    |
|   10   |  1010  |    {B, D}    |
|   11   |  1011  |  {A, B, D}   |
|   12   |  1100  |    {C, D}    |
|   13   |  1101  |  {A, C, D}   |
|   14   |  1110  |  {B, C, D}   |
|   15   |  1111  | {A, B, C, D} |

- 원소가 n 인 집합 부분집합의 개수는 $2^n$ = `1 << n`

# 코드로 부분집합 출력해보기

```cpp
#include <iostream>
using namespace std;

char arr[4] = { 'A', 'B', 'C', 'D' };

void printSubsets(int n) {
	// 0 -15 가지 부분집합 모두 탐색
	for (int i = 0; i < (1 << n); ++i) {
		cout << "{";
		// 0 - 3 인덱스 모두 탐색
		for (int j = 0; j < n; ++j) {
			// 각각의 인덱스의 char 이 있는지 확인
			if (i & (1 << j)) {
				cout << arr[j] << " ";
			}
		}
		cout << "}" << endl;
	}
}

int main()
{
	printSubsets(4);
	return 0;
}
```

## 출력 결과

```plain text
{}
{A }
{B }
{A B }
{C }
{A C }
{B C }
{A B C }
{D }
{A D }
{B D }
{A B D }
{C D }
{A C D }
{B C D }
{A B C D }
```

# 원소의 개수 세기

## 1. Bitset STL 활용

```cpp
#include <bitset>
#include <iostream>
using namespace std;

int countBits(int n) {
	bitset<4> set(n);
	return set.count();
}

int main()
{
	char arr[4] = { 'A', 'B', 'C', 'D' };
	int arr_size = 4;

	for (int i = 0; i < (1 << arr_size); i++) {
		cout << "비트마스크 " << i << "(" << bitset<4>(i) << ") -> ";
		cout << "원소 개수: " << countBits(i) << endl;
	}
	return 0;
}
```

### 결과

```plain text
비트마스크 0 (0000) -> 원소 개수: 0
비트마스크 1 (0001) -> 원소 개수: 1
비트마스크 2 (0010) -> 원소 개수: 1
비트마스크 3 (0011) -> 원소 개수: 2
비트마스크 4 (0100) -> 원소 개수: 1
비트마스크 5 (0101) -> 원소 개수: 2
비트마스크 6 (0110) -> 원소 개수: 2
비트마스크 7 (0111) -> 원소 개수: 3
비트마스크 8 (1000) -> 원소 개수: 1
비트마스크 9 (1001) -> 원소 개수: 2
비트마스크 10 (1010) -> 원소 개수: 2
비트마스크 11 (1011) -> 원소 개수: 3
비트마스크 12 (1100) -> 원소 개수: 2
비트마스크 13 (1101) -> 원소 개수: 3
비트마스크 14 (1110) -> 원소 개수: 3
비트마스크 15 (1111) -> 원소 개수: 4
```

## 직접 구현

```cpp
#include <bitset>
#include <iostream>
#include <cmath>
using namespace std;

int countBits(int n) {
	int ret = 0;
	while (n) {
		if (n & 1) ret++;
		n = n >> 1; // 맨 오른쪽 비트를 센 후 오른쪽으로 shift 해서 하나 없애기
	}
	return ret;
}

int main()
{
	char arr[4] = { 'A', 'B', 'C', 'D' };
	int arr_size = 4;

	for (int i = 0; i < (1 << arr_size); i++) {
		cout << "비트마스크 " << i << "(" << bitset<4>(i) << ") -> ";
		cout << "원소 개수: " << countBits(i) << endl;
	}

	return 0;
}
```

- 결과는 동일

# JWT 개요

## 📚 목차

1. [JWT 등장 배경](#1-jwt-등장-배경)
2. [JWT란 무엇인가?](#2-jwt란-무엇인가)
3. [JWT의 구성](#3-jwt의-구성)
4. [JWT 동작 과정](#4-jwt-동작-과정)

---

# 1. JWT 등장 배경

## 1.1 클라이언트가 다양해짐

예전에는 웹 사이트만 있으면 충분했음

- 브라우저는 쿠키를 자동으로 관리
- 서버는 세션을 통해 인증
- 별다른 문제가 없었음

---

> #### 💡 참고: 쿠키와 세션 기반 인증의 동작 과정
>
> 1. 클라이언트가 로그인 요청을 보냄
> 
> 2. 서버가 로그인 정보를 확인함
> 
> 3. 서버가 새로운 세션을 생성
>    - 랜덤한 세션 ID를 생성
>    - 세션 저장소에 사용자 정보 저장
>    
>    ```
>    세션 저장소
>    ------------------------------------
>    세션ID: XJ29AB
>    값: { userId: 123, name: "햄버거", role: "USER" }
>    ```
> 4. 서버가 세션 id 를 클라이언트 쿠키에 넣어둠  
>
>    ```http
>    Set-Cookie: SESSIONID=XJ29AB;
>    ```
> 
> 5. 이후 모든 요청에서 브라우저가 쿠키를 자동 포함
>    
>    ```http
>    Cookie: SESSIONID=XJ29AB
>    ```
> 
> 6. 서버는 쿠키의 세션 ID로 세션 저장소를 조회함

---

### 📱 현재: 다양한 클라이언트 환경

그런데 요즘은

- React/Vue/Nest.js 같은 SPA
- iOS/Android 네이티브 앱
- 데스크 탑 앱, IoT 기기 등

즉, 브라우저가 아닌 환경에서 API를 호출하는 경우가 많아짐

**⚠️ 문제점**: 이러한 환경들은 쿠키를 자동으로 관리해주지 않아 로그인 유지가 어려워짐

## 1.2 CORS 정책으로 인한 복잡성 증가

쿠키는 원래 도메인에서만 안전하게 쓰라고 설계되었기 때문에, 다른 도메인 간에 사용하려면 브라우저가 매우 까다롭게 검사함

### 예시 1: 같은 도메인 (문제 없음)

```
브라우저 (www.example.com)
    ↕
서버 (www.example.com)
```

✅ **같은 도메인** → 쿠키 자동 전송 → 아무 문제 없음

### 예시 2: 다른 도메인 (문제 발생)

```
프론트엔드: localhost:3000 (React 개발 서버)
    ↕
백엔드: localhost:8080 (Spring)
```

⚠️ **다른 도메인** → 브라우저가 보안 검사 시작

### 🚨 CORS + 쿠키 조합에서 생길 수 있는 문제들

1. 브라우저가 기본적으로 쿠키 전송을 막음
   - `withCredentials` 등 추가 설정 필요

2. 서버는 CORS 설정에 정확한 도메인을 명시해야 함
   - `Access-Control-Allow-Origin`: 와일드카드(`*`) 사용 불가

3. SameSite 정책 때문에 cross-site 쿠키를 거의 보내지 않음
   - `SameSite=None; Secure` 설정 필수

4. 모바일 앱에서는 CORS가 적용되지 않음
   - 별도의 쿠키 로직 필요
   - 환경마다 인증 처리 방식이 달라져 유지보수 복잡

---

> #### 💡 참고: CORS 정책이란?
>
> **CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)**  
> 웹 브라우저가 다른 출처의 서버와 통신할 때 보안을 위해 적용하는 규칙
>
> ---
>
> #### ✔️ 출처(Origin)의 판단 기준
>
> 출처는 아래 3가지가 모두 같아야 동일 출처임
>
> - 프로토콜 (http / https)
> - 도메인 (example.com)
> - 포트 번호 (80, 443, 8080 등)
>
> ##### 예시
>
> | URL                          | 동일 출처 여부        | 이유               |
> |------------------------------|------------------|------------------|
> | `https://example.com:443`    | ✅         | 모두 같음            |
> | `https://example.com`        | ✅          | 443 포트 생략        |
> | `http://example.com`         | ❌          | 프로토콜 다름          |
> | `http://example.com:8080`    | ❌          | 포트 다름            |
> | `http://api.example.com`     | ❌         | 서브도메인 다름         |
>
> ---
>
> #### CORS 정책이 필요한 이유
>
> 브라우저는 다른 출처로 요청이 갈 때 다음 두 가지를 확인함:
>
> 1. **이 요청이 안전한가?**  
> 2. **서버가 이 출처의 요청을 허용했는가?**
>
> **검사 이유**
> 
> 악성 사이트가 "사용자의 브라우저"를 이용해 사용자 몰래 API 요청을 보내고 정보를 탈취하는 것을 막기 위함
>
> 즉, **브라우저가 사용자 보안을 지키기 위해 출처가 다르면 요청을 제한하는 정책**이 바로 CORS!

---

## 1.3 세션 방식의 확장성 문제

세션 방식은 서버를 1대만 쓸 때는 아무 문제가 없지만, 서비스가 커져서 여러 대로 늘리면(Scale-out) 문제가 발생

### 🔄 문제 상황

```
사용자 요청 → 서버 A (세션 정보 저장됨)
다음 요청 → 서버 B (세션 정보 없음)
```

서버 B 입장에서는:

```
"어? 세션 ID는 왔는데… 난 그 세션 정보가 없는데?"
→ 인증 실패 
```

### 해결하려고 나온 3가지 방법

#### 1. Sticky Session (고정 세션)

- 사용자가 로그인하면 그 사용자는 계속 같은 서버로만 연결되도록 고정

- 문제점: 서버 A가 내려가면 그 서버에 묶인 사용자 전부 로그아웃됨

#### 2. Session Clustering (세션 클러스터링)

- 여러 서버가 서로 세션 정보를 복제해서 공유

- 문제점: 서버가 늘어날수록 복제 비용 폭증, 네트워크 트래픽 증가

#### 3. Session Server/Session Storage (세션 중앙화)

- 세션 서버를 따로 둠 (ex. Redis)

- 문제점: Redis 장애 시 전체 로그인 기능이 중단됨, 여전히 상태를 저장하는 방식(Stateful)

---

#### 그래서 JWT 가 등장!

세션 방식(Stateful)은 서버가 늘어날수록 복잡해지는 반면,

**JWT의 장점**:
- 서버에 상태를 저장하지 않음 (**Stateless**)
- 여러 서버가 있어도 인증 문제 없음
- **Scale-out** 환경에 최적화됨

---

# 2. JWT란 무엇인가?

## 2.1 JWT 정의

- 서버가 사용자 정보를 담아서 암호화해 만든 토큰을 **클라이언트가 직접 가지고 다니는** 방식의 인증
- 클라이언트가 **매 요청마다 JWT를 함께 보냄**
- 서버는 **JWT가 위조되었는지만 검사**하면 됨

## 2.2 동작 과정

### 1️⃣ 클라이언트 → 서버: 로그인 요청

### 2️⃣ 서버: JWT 생성

```json
{
  "userId": 123,
  "name": "햄버거",
  "role": "USER",
  "exp": "2025-12-10T10:00:00"
}
```

### 3️⃣ 서버 → 클라이언트: JWT 반환

### 4️⃣ 클라이언트 → 서버: API 요청 시 JWT 전송

모든 요청마다 HTTP 헤더에 JWT를 넣어서 보냄

```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 5️⃣ 서버: JWT 검증 & 사용자 확인

## 2.3 Session Cookie vs JWT

<img src="./img/1.png">

| 구분 | **Session 기반 인증** | **JWT 기반 인증** |
|------|---------------------|------------------|
| **인증 정보 저장 위치** | 서버 세션 저장소 | 토큰(JWT) 안에 직접 포함 |
| **클라이언트가 보관하는 것** | Session ID | JWT 토큰 자체 |
| **요청 시 전송** | 쿠키 자동 포함<br>(`Cookie: SESSIONID=...`) | 헤더에 수동 포함<br>(`Authorization: Bearer <token>`) |
| **서버의 인증 처리 방식** | 세션 ID → 세션 저장소 조회<br>→ 사용자 정보 확인 | JWT 자체를 검증(Signature, exp)<br>→ payload로 사용자 정보 확인 |
| **서버 확장(Scale-out)** | ❌ 어려움: 세션 공유 필요<br>(sticky session / session clustering 등) | ✅ 매우 쉬움: Stateless라<br>어떤 서버로 가도 동일하게 처리됨 |
| **보안 의존성** | 서버 저장소 관리 | 토큰 탈취 위험 있지만 변조 불가(서명) |
| **만료 처리** | 서버가 직접 세션 제거 | 토큰 exp로 자동 만료 |
| **장점** | • 간단하고 익숙함<br>• 서버가 즉시 세션 무효화 가능 | • 확장성 뛰어남<br>• 브라우저 외 환경(앱, IoT)에서도 편리 |
| **단점** | • 서버 메모리 사용 ↑<br>• 확장 어려움 | • 토큰 탈취 시 만료 전까지 유효<br>• 재발급 로직 필요 |

### ⚠️ 중요한 오해

- JWT가 더 보안적으로 뛰어나서 사용하는 것이 아님!
- **편의성과 확장성** 때문에 사용!

---

# 3. JWT의 구성

JWT는 세 부분으로 구성되며, .(점)으로 구분

```
Header.Payload.Signature
```

## 3.1 Header (헤더)

토큰에 대한 메타데이터로, 다음 정보를 포함:

- 토큰의 유형 (ex. JWT)
- 서명 알고리즘 (ex. HS256, RS256)

즉, **이 토큰을 어떻게 해석할 것인지**에 대한 정보

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

## 3.2 Payload (페이로드)

토큰에 담고 싶은 **사용자 정보나 추가 데이터**

- 사용자 정보 (ID, 권한, 이름)
- 토큰 정보 (만료 시간 등)
- Key-Value 쌍으로 구성

```json
{
  "userId": 123,
  "name": "햄버거",
  "role": "USER",
  "exp": 1732843200
}
```

⚠️ 주의: 전부 Base64로 인코딩되어 있어 암호화가 아님 → 누구나 볼 수 있음

## 3.3 Signature (서명)

Header + Payload를 서버의 Secret Key로 암호학적으로 해시한 값

- 마지막에 Base64로 인코딩됨
- 토큰의 무결성을 보장

### 서버에서 토큰 검증할 때 하는 일

1. 토큰에서 Header·Payload 추출
2. 서버가 가진 Secret Key로 다시 서명
3. 클라이언트가 보낸 Signature와 같은지 비교

### ✅ 검증 결과

- Signature가 일치 → 서버가 만든 진짜 토큰
- Signature가 불일치 → 위조된 토큰 (내용이 변조됨)

---

# 4. JWT 동작 과정

## 4.1 실제 JWT 토큰 예시

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.eyJ1c2VySWQiOjEyMywibmFtZSI6Iu2VnOyalCIsInJvbGUiOiJVU0VSIiwiZXhwIjoxNzMyODQzMjAwfQ
.8ZCvoq6stOiNBg_7me7rO3RrDBA8iUvYHWTpTaQDryU
```

위 토큰은 다음과 같이 구성됨:

| 부분 | 내용 |
|------|------|
| **Header** | `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9` |
| **Payload** | `eyJ1c2VySWQiOjEyMywibmFtZSI6Iu2VnOyalCIsInJvbGUiOiJVU0VSIiwiZXhwIjoxNzMyODQzMjAwfQ` |
| **Signature** | `8ZCvoq6stOiNBg_7me7rO3RrDBA8iUvYHWTpTaQDryU` |

## 4.2 검증 프로세스

### 1️⃣ 서버가 JWT 수신

클라이언트로부터 JWT 토큰을 받음

### 2️⃣ Header + Payload 추출

서버는 받은 JWT에서 Header와 Payload 부분을 추출

### 3️⃣ 새로운 Signature 생성

서버가 가진 **Secret Key**를 사용하여 새로운 Signature를 만듭니다.

```
새로운 Signature = HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

### 4️⃣ Signature 비교

생성한 Signature와 JWT의 Signature가 같은지 비교

```
JWT의 Signature: 8ZCvoq6stOiNBg_7me7rO3RrDBA8iUvYHWTpTaQDryU
새로 생성한 Signature: 8ZCvoq6stOiNBg_7me7rO3RrDBA8iUvYHWTpTaQDryU
```

- 일치 → 인증 성공  
- 불일치 → 인증 실패 (토큰 위조됨)

---

## 4.3 JWT Decoder 예시

<img src="./img/2.png">

[jwt.io](https://jwt.io)에서 JWT 토큰을 디코딩하여 내용을 확인할 수 있음

---

## 📝 중요 포인트

- JWT는 인증 방식이 아니라 단순한 토큰 포맷임
- 표준화된 구현 방식이 존재하지 않아, 각 환경에 맞게 구현해야 함

# 데이터베이스 모델링

## 목차

1. 데이터베이스 모델링
2. 요구사항 수집 및 분석
3. 개념적 데이터 모델링
4. 논리적 데이터 모델링
5. 물리적 데이터 모델링

---

## 1. 데이터베이스 모델링

**모델링:** 현실 세계를 이해하기 쉽게 **모형으로 만드는 작업**  

### Database Modeling

<img src="./img/1.png">

- 현실 세계 데이터를 분석 → 데이터 종류와 관계 설계  
- 컴퓨터에 오래 보관, 효율적으로 꺼내 쓸 수 있도록 구조화  

### 예시: 카페 주문 시스템

#### 어떤 데이터가 있는가?

- **손님(Customer)** → 이름, 전화번호  
- **메뉴(Menu)** → 메뉴명, 가격  
- **주문(Order)** → 주문시간, 결제금액  

#### 데이터 간 관계

| 관계 | 설명 |
| ------- | --------------------------------- |
| 손님 ↔ 주문 | 한 명의 손님이 여러 번 주문 가능 (1:N 관계) |
| 주문 ↔ 메뉴 | 한 번의 주문에 여러 메뉴 포함 가능 (N:M 관계) |

---

## Database Modeling 필요성

### 1. 데이터 무결성 유지
- 데이터 일관성 및 정확성 보장  
- 제약조건과 트랜잭션 적용 가능  

#### 예시

| 고객명 | 전화번호         |
| ------ | ---------------- |
| 김하늘 | 010-1234-5678    |
| 김하늘 | 010-1234-5678    |
| 김하늘 | 010-9999-8888 ❌ |

- 고객 테이블과 고유 ID 관리 → 오류 방지  

### 2. 중복 최소화

#### 예시

| 주문번호 | 고객명 | 전화번호      | 메뉴명     |
| -------- | ------ | ------------- | ---------- |
| 1        | 김하늘 | 010-1234-5678 | 아메리카노 |
| 2        | 김하늘 | 010-1234-5678 | 라떼       |

- 같은 정보 반복 → 저장 공간 낭비 + 수정 번거로움  

### 3. 효율적인 데이터 검색

- 잘 연결된 구조 → JOIN 한 번으로 쉽게 조회 가능  
- 인덱스 활용 가능  

### 4. 유지보수 용이성

- 데이터 구조 변경 시 최소한 영향  
- 예: 포인트 적립 기능 추가 → Point 테이블 + Customer 관계 연결

---

## 2. 요구사항 수집 및 분석

- 현실 세계에서 저장할 데이터와 사용자 요구 정리  
- 사용자 역할 식별(회원, 관리자 등)  
- 프로세스 모델링 → 데이터 입력/출력 명확화  
- 화면 설계 → 데이터 입력/출력 확인 → DB 모델링 진행  

---

## 3. 개념적 데이터 모델링

- 비즈니스 요구 반영 → **엔티티, 속성, 관계 정의**  
- **ER 모델(개체-관계 모델)** 활용  

#### 엔티티 유형

| 구분 | 설명 | 예시 |
| ---- | ---- | ---- |
| 유형 엔티티 | 물리적 형태 있는 엔티티 | 사원, 상품, 도서 |
| 개념 엔티티 | 물리적 형태 없지만 관리 필요 | 부서, 장소, 보험상품 |
| 사건 엔티티 | 업무 수행 시 발생 | 주문, 청구, 대출 |

| 구분 | 설명 | 예시 |
| ---- | ---- | ---- |
| 기본 엔티티 | 원래 존재하는 정보 | 사원, 상품, 고객 |
| 중심 엔티티 | 기본 엔티티로부터 발생, 업무 중심 | 주문, 청구, 계약 |
| 행위 엔티티 | 중심 엔티티에서 파생된 세부 정보 | 주문 목록, 계약 진행 |

#### 개체 검증 (CRUD Matrix)

| 엔티티타입 | 신규고객등록 | 주문신청 | 주문취소 |
| ---------- | ----------- | -------- | -------- |
| 고객       | C, R, U     | R        | R        |
| 주문       |             | C, R, D  | D        |
| 주문목록   |             | C, R     | D        |
| 제품       | R           | R        | R        |

#### CRUD 체크리스트

| 번호 | 체크 항목 | 쉽게 설명 |
| ---- | -------- | -------- |
| 1    | 모든 엔티티타입이 CRUD 한 번 이상 표기되었는가? | 모든 테이블 후보가 사용되는지 확인 |
| 2    | 모든 엔티티타입에 C가 있는가? | 생성 과정이 있어야 함 |
| 3    | 모든 엔티티타입에 R이 있는가? | 조회 가능해야 함 |
| 4    | 모든 단위 프로세스가 엔티티타입에 연결되었는가? | 데이터와 관련 없는 프로세스가 없는지 확인 |
| 5    | 두 개 이상의 단위 프로세스가 하나의 엔티티타입을 생성하는가? | 충돌/중복 위험 방지 |

---

## 4. 속성

| 속성 구분 | 뜻 | 예시 |
| ---------- | ------------------------- | -------------------------- |
| 기본속성 | 현실에서 바로 얻을 수 있는 정보 | 이름, 생일, 주소, 전화번호 |
| 설계속성 | 다른 엔티티에서 가져오는 속성 | 학번의 학교코드, 주문의 고객ID |
| 파생속성 | 다른 속성으로 계산되는 속성 | 나이(오늘날짜-생일), 총금액(수량×단가) |

---

## 5. 키 속성 추출

| 키 이름 | 설명 | 예시 |
| -------- | ------------------------------- | ----------------------- |
| 슈퍼키 | 행 구분 가능한 모든 속성 집합 | {학생번호}, {이름+전화번호} |
| 후보키 | 최소 속성으로 구분 가능한 키 | {학생번호}, {전화번호} |
| 기본키 | 후보키 중 대표 키 | 학생번호 |
| 대체키 | 후보키 중 기본키 아닌 키 | 전화번호 |
| 외래키 | 다른 테이블 기본키 참조 | 주문 테이블 고객ID → 고객 테이블 PK |

| 구분 | 설명 | 예시 |
| ---- | ---- | ---- |
| 자연키 | 현실에 존재하는 값으로 식별 | 주민등록번호, 학번 |
| 인조키 | 개발자가 새로 만든 키 | 회원번호, 주문번호, 게시글ID |

---

## 6. 관계 차수

| 관계차수 | 이름 | 설명 | 예시 |
| -------- | ---- | ---- | ---- |
| 1:1 | 일대일 | 한 개체 ↔ 한 개체 | 사람 – 주민등록증 |
| 1:N | 일대다 | 한 개체 ↔ 여러 개체 | 학급 – 학생 |
| M:N | 다대다 | 여러 개체 ↔ 여러 개체 | 학생 – 과목 |

---

## 7. 피터첸 표기법

| 요소 | 표기 | 설명 |
| ---- | ---- | ---- |
| 엔티티 | ▭ 직사각형 | 저장할 대상 |
| 속성 | ⭕ 타원 | 엔티티 특징 |
| 기본키 | ⭕ 밑줄 | 엔티티 구별 속성 |
| 다중값 속성 | ⭕ 이중 타원 | 여러 값 가능 |
| 관계 | ◇ 마름모 | 엔티티 간 연결 |
| 카디널리티 | 선 옆 숫자 | 1, N, M 등 |

**예시**
```
 (학생ID)
    ⭕
     │
     │
⭕-- 이름
     │
   ┌───────┐
   │  학생  │
   └───────┘
        │
        │  (수강한다)
        ▼
   ◇────────◇
        │
        ▼
   ┌───────┐
   │  과목  │
   └───────┘
     │     │
 ⭕이름   ⭕학점
```


---

## 8. 논리적 데이터 모델링

| 항목 | ER 모델(E-R, 개념/논리) | 관계형 데이터 모델 |
| ---- | -------------------- | ---------------- |
| 정의 | 현실 세계 개체와 관계 추상화 | ER 모델 → DB 테이블 구조로 변환 |
| 단위 | 엔티티, 속성, 관계 | 릴레이션(테이블), 컬럼 |
| 속성 | 기본, 파생, 다중값 | 컬럼, 다중값 → 별도 테이블 |
| 키 | 후보키, 기본키, 대체키 | PK, UNIQUE, FK |
| 관계 | 1:1, 1:N, M:N | 1:1 → FK, 1:N → FK, M:N → 조인테이블 |
| 카디널리티 | 관계차수 표시 | FK 제약, 조인테이블로 구현 |

---

## 9. N:M 관계 해소

- N:M 관계 → 데이터 중복 가능  
- 해결: 조인 테이블 생성, 복합키 사용 또는 인조키 생성  

**예시: 학생-과목**

| 학생ID | 학생이름 | 과목ID | 과목명 |
| ------- | -------- | ------- | ------- |
| 1       | 민지     | A       | 수학    |
| 1       | 민지     | B       | 영어    |
| 2       | 철수     | A       | 수학    |
| 2       | 철수     | B       | 영어    |

- 데이터 중복 발생 → 수정/삭제 어려움  

---

## 10. 정규화

- **정규화:** 중복 최소화, 이상 방지  

**정규화 단계**

1. **1NF:** 속성은 단일값  
2. **2NF:** 부분 종속 제거, 모든 속성은 기본키에 종속  
3. **3NF:** 이행 종속 제거, 기본키 아닌 속성끼리 종속 금지  

[정규화 예시 참고 블로그](https://velog.io/@kyodong_han/SQL-데이터-모델과-SQL)

---

## 11. 물리적 데이터 모델링

- 실제 DB에서 성능 중심 설계  
- **역정규화:** 성능 향상 위해 일부 중복 허용/테이블 합침  

#### 예시

- 컬럼 역정규화: 잦은 조인 줄이기 위해 컬럼 추가  
- 테이블 역정규화: 너무 쪼갠 테이블 합쳐 조회 성능 향상  

| 개념/요소 | 구현 |
| ---------- | ---- |
| 릴레이션 | 테이블 |
| 속성 | 컬럼 |
| 기본키 | PK 제약조건 |
| 대체키 | UNIQUE 제약조건 |
| 외래키 | FK 제약조건 |
| 제약조건 | PK, UNIQUE, FK, NOT NULL 등 |
| 관계 | 1:1, 1:N → FK / M:N → 조인테이블 |

---

## 12. 산출물

- 개념 ERD  
- 논리 ERD (릴레이션 스키마)  
- 물리 ERD  
- 최적화된 DB 테이블 구조
